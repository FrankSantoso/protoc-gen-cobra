package main

import (
	"fmt"
	"sort"
	"strings"
	"text/template"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
)

func genFile(gen *protogen.Plugin, file *protogen.File) error {
	if len(file.Services) == 0 {
		return nil
	}

	g := gen.NewGeneratedFile(file.GeneratedFilenamePrefix+".cobra.pb.go", file.GoImportPath)
	g.P("// Code generated by protoc-gen-cobra. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	for _, srv := range file.Services {
		if err := genService(g, srv); err != nil {
			return err
		}
	}

	return nil
}

var (
	serviceTemplateCode = `
func {{.GoName}}ClientCommand(cfgs ...*client.Config) *cobra.Command {
	cfg := client.DefaultConfig
	if len(cfgs) > 0 {
		cfg = cfgs[0]
	}
	cmd := &cobra.Command{
		Use: "{{.GoName | toLower}}",
		Short: "{{.GoName}} service client",
		Long: "{{.Comments.Leading | cleanComments}}",{{if .Desc.Options.GetDeprecated}}
		Deprecated: "deprecated",{{end}}
	}
	cfg.BindFlags(cmd.PersistentFlags())
	d := &client.Dialer{Config: cfg}
	cmd.AddCommand({{range .Methods}}
		_{{$.GoName}}{{.GoName}}Command(d),{{end}}
	)
	return cmd
}
`
	serviceTemplate = template.Must(template.New("service").
		Funcs(template.FuncMap{"toLower": strings.ToLower, "cleanComments": cleanComments}).
		Parse(serviceTemplateCode))
	serviceImports = []protogen.GoImportPath{
		"github.com/NathanBaulch/protoc-gen-cobra/client",
		"github.com/spf13/cobra",
	}
)

func genService(g *protogen.GeneratedFile, service *protogen.Service) error {
	for _, imp := range serviceImports {
		g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: imp})
	}
	if err := serviceTemplate.Execute(g, service); err != nil {
		return err
	}

	enums := make(map[string]*enum)

	for _, mth := range service.Methods {
		if err := genMethod(g, mth, enums); err != nil {
			return err
		}
	}

	if len(enums) > 0 {
		names := make([]string, len(enums))
		i := 0
		for name := range enums {
			names[i] = name
			i++
		}
		sort.Strings(names)
		for _, name := range names {
			if err := genEnum(g, enums[name]); err != nil {
				return err
			}
		}
	}

	return nil
}

var (
	methodTemplateCode = `
func _{{.Parent.GoName}}{{.GoName}}Command(d *client.Dialer) *cobra.Command {
	req := {{.InputInitializerCode}}

	cmd := &cobra.Command{
		Use: "{{.GoName | toLower}}",
		Short: "{{.GoName}} RPC client",
		Long: "{{.Comments.Leading | cleanComments}}",{{if .Desc.Options.GetDeprecated}}
		Deprecated: "deprecated",{{end}}
		RunE: func(cmd *cobra.Command, args []string) error {
			if d.UseEnvVars {
				if err := flag.SetFlagsFromEnv(cmd.Parent().PersistentFlags(), d.EnvVarPrefix); err != nil {
					return err
				}
				if err := flag.SetFlagsFromEnv(cmd.PersistentFlags(), d.EnvVarPrefix, "{{.Parent.GoName | toUpper}}", "{{.GoName | toUpper}}"); err != nil {
					return err
				}
			}
			return d.RoundTrip(cmd.Context(), func(cc grpc.ClientConnInterface, in iocodec.Decoder, out iocodec.Encoder) error {
				cli := New{{.Parent.GoName}}Client(cc)
				v := &{{.Input.GoIdent.GoName}}{}
	{{if .Desc.IsStreamingClient}}
				stm, err := cli.{{.GoName}}(cmd.Context())
				if err != nil {
					return err
				}
				for {
					if err := in(v); err != nil {
						if err == io.EOF {
							_ = stm.CloseSend()
							break
						}
						return err
					}
					proto.Merge(v, req)
					if err = stm.Send(v); err != nil {
						return err
					}
				}
	{{else}}
				if err := in(v); err != nil {
					return err
				}
				proto.Merge(v, req)
		{{if .Desc.IsStreamingServer}}
				stm, err := cli.{{.GoName}}(cmd.Context(), v)
		{{else}}
				res, err := cli.{{.GoName}}(cmd.Context(), v)
		{{end}}
				if err != nil {
					return err
				}
	{{end}}
	{{if .Desc.IsStreamingServer}}
				for {
					res, err := stm.Recv()
					if err != nil {
						if err == io.EOF {
							break
						}
						return err
					}
					if err = out(res); err != nil {
						return err
					}
				}
				return nil
	{{else}}
		{{if .Desc.IsStreamingClient}}
				res, err := stm.CloseAndRecv()
				if err != nil {
					return err
				}
		{{end}}
				return out(res)
	{{end}}
			})
		},
	}

	{{.InputFieldFlagCode}}

	return cmd
}
`
	methodTemplate = template.Must(template.New("method").
		Funcs(template.FuncMap{"toLower": strings.ToLower, "toUpper": strings.ToUpper, "cleanComments": cleanComments}).
		Parse(methodTemplateCode))
	methodImports = []protogen.GoImportPath{
		"github.com/golang/protobuf/proto",
		"github.com/NathanBaulch/protoc-gen-cobra/client",
		"github.com/NathanBaulch/protoc-gen-cobra/flag",
		"github.com/NathanBaulch/protoc-gen-cobra/iocodec",
		"github.com/spf13/cobra",
		"google.golang.org/grpc",
	}
)

func genMethod(g *protogen.GeneratedFile, method *protogen.Method, enums map[string]*enum) error {
	for _, imp := range methodImports {
		g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: imp})
	}
	if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
		g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: "io"})
	}

	initCode, flagCode := walkFields(g, method.Input, nil, enums, false, make(map[protogen.GoIdent]bool))
	data := struct {
		*protogen.Method
		InputInitializerCode string
		InputFieldFlagCode   string
	}{method, initCode, flagCode}
	return methodTemplate.Execute(g, data)
}

var (
	flagPkg      = protogen.GoImportPath("github.com/NathanBaulch/protoc-gen-cobra/flag")
	wrappersPkg  = protogen.GoImportPath("github.com/golang/protobuf/ptypes/wrappers")
	timestampPkg = protogen.GoImportPath("github.com/golang/protobuf/ptypes/timestamp")
	durationPkg  = protogen.GoImportPath("github.com/golang/protobuf/ptypes/duration")
	knownTypes   = map[protogen.GoIdent][]protogen.GoIdent{
		timestampPkg.Ident("Timestamp"):  {flagPkg.Ident("TimestampVar"), flagPkg.Ident("TimestampSliceVar")},
		durationPkg.Ident("Duration"):    {flagPkg.Ident("DurationVar"), flagPkg.Ident("DurationSliceVar")},
		wrappersPkg.Ident("DoubleValue"): {flagPkg.Ident("DoubleWrapperVar"), flagPkg.Ident("DoubleWrapperSliceVar")},
		wrappersPkg.Ident("FloatValue"):  {flagPkg.Ident("FloatWrapperVar"), flagPkg.Ident("FloatWrapperSliceVar")},
		wrappersPkg.Ident("Int64Value"):  {flagPkg.Ident("Int64WrapperVar"), flagPkg.Ident("Int64WrapperSliceVar")},
		wrappersPkg.Ident("UInt64Value"): {flagPkg.Ident("UInt64WrapperVar"), flagPkg.Ident("UInt64WrapperSliceVar")},
		wrappersPkg.Ident("Int32Value"):  {flagPkg.Ident("Int32WrapperVar"), flagPkg.Ident("Int32WrapperSliceVar")},
		wrappersPkg.Ident("UInt32Value"): {flagPkg.Ident("UInt32WrapperVar"), flagPkg.Ident("UInt32WrapperSliceVar")},
		wrappersPkg.Ident("BoolValue"):   {flagPkg.Ident("BoolWrapperVar"), flagPkg.Ident("BoolWrapperSliceVar")},
		wrappersPkg.Ident("StringValue"): {flagPkg.Ident("StringWrapperVar"), flagPkg.Ident("StringWrapperSliceVar")},
		wrappersPkg.Ident("BytesValue"):  {flagPkg.Ident("BytesBase64WrapperVar"), flagPkg.Ident("BytesBase64WrapperSliceVar")},
	}
)

func walkFields(g *protogen.GeneratedFile, message *protogen.Message, path []string, enums map[string]*enum, deprecated bool, visited map[protogen.GoIdent]bool) (string, string) {
	var initLines []string
	flagLines := make([]string, 0, len(message.Fields))

	for _, fld := range message.Fields {
		var flagLine string
		path := append(path, fld.GoName)
		goPath := strings.Join(path, ".")
		flagName := strings.ToLower(strings.Join(path, "-"))
		comment := cleanComments(fld.Comments.Leading)
		deprecated := deprecated || fld.Desc.Options().(*descriptorpb.FieldOptions).GetDeprecated()

		switch fld.Desc.Kind() {
		case protoreflect.BoolKind:
			if fld.Desc.IsList() {
				flagLine = fmt.Sprintf("cmd.PersistentFlags().BoolSliceVar(&req.%s, %q, nil, %q)", goPath, flagName, comment)
			} else if !fld.Desc.HasPresence() {
				flagLine = fmt.Sprintf("cmd.PersistentFlags().BoolVar(&req.%s, %q, false, %q)", goPath, flagName, comment)
			} else {
				flagLine = fmt.Sprintf("flag.BoolPointerVar(cmd.PersistentFlags(), &req.%s, %q, %q)", goPath, flagName, comment)
			}
		case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
			if fld.Desc.IsList() {
				flagLine = fmt.Sprintf("cmd.PersistentFlags().Int32SliceVar(&req.%s, %q, nil, %q)", goPath, flagName, comment)
			} else if !fld.Desc.HasPresence() {
				flagLine = fmt.Sprintf("cmd.PersistentFlags().Int32Var(&req.%s, %q, 0, %q)", goPath, flagName, comment)
			} else {
				flagLine = fmt.Sprintf("flag.Int32PointerVar(cmd.PersistentFlags(), &req.%s, %q, %q)", goPath, flagName, comment)
			}
		case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
			if fld.Desc.IsList() {
				id := g.QualifiedGoIdent(flagPkg.Ident("Uint32SliceVar"))
				flagLine = fmt.Sprintf("%s(cmd.PersistentFlags(), &req.%s, %q, %q)", id, goPath, flagName, comment)
			} else if !fld.Desc.HasPresence() {
				flagLine = fmt.Sprintf("cmd.PersistentFlags().Uint32Var(&req.%s, %q, 0, %q)", goPath, flagName, comment)
			} else {
				flagLine = fmt.Sprintf("flag.Uint32PointerVar(cmd.PersistentFlags(), &req.%s, %q, %q)", goPath, flagName, comment)
			}
		case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
			if fld.Desc.IsList() {
				flagLine = fmt.Sprintf("cmd.PersistentFlags().Int64SliceVar(&req.%s, %q, nil, %q)", goPath, flagName, comment)
			} else if !fld.Desc.HasPresence() {
				flagLine = fmt.Sprintf("cmd.PersistentFlags().Int64Var(&req.%s, %q, 0, %q)", goPath, flagName, comment)
			} else {
				flagLine = fmt.Sprintf("flag.Int64PointerVar(cmd.PersistentFlags(), &req.%s, %q, %q)", goPath, flagName, comment)
			}
		case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
			if fld.Desc.IsList() {
				id := g.QualifiedGoIdent(flagPkg.Ident("Uint64SliceVar"))
				flagLine = fmt.Sprintf("%s(cmd.PersistentFlags(), &req.%s, %q, %q)", id, goPath, flagName, comment)
			} else if !fld.Desc.HasPresence() {
				flagLine = fmt.Sprintf("cmd.PersistentFlags().Uint64Var(&req.%s, %q, 0, %q)", goPath, flagName, comment)
			} else {
				flagLine = fmt.Sprintf("flag.Uint64PointerVar(cmd.PersistentFlags(), &req.%s, %q, %q)", goPath, flagName, comment)
			}
		case protoreflect.FloatKind:
			if fld.Desc.IsList() {
				flagLine = fmt.Sprintf("cmd.PersistentFlags().Float32SliceVar(&req.%s, %q, nil, %q)", goPath, flagName, comment)
			} else if !fld.Desc.HasPresence() {
				flagLine = fmt.Sprintf("cmd.PersistentFlags().Float32Var(&req.%s, %q, 0, %q)", goPath, flagName, comment)
			} else {
				flagLine = fmt.Sprintf("flag.Float32PointerVar(cmd.PersistentFlags(), &req.%s, %q, %q)", goPath, flagName, comment)
			}
		case protoreflect.DoubleKind:
			if fld.Desc.IsList() {
				flagLine = fmt.Sprintf("cmd.PersistentFlags().Float64SliceVar(&req.%s, %q, nil, %q)", goPath, flagName, comment)
			} else if !fld.Desc.HasPresence() {
				flagLine = fmt.Sprintf("cmd.PersistentFlags().Float64Var(&req.%s, %q, 0, %q)", goPath, flagName, comment)
			} else {
				flagLine = fmt.Sprintf("flag.Float64PointerVar(cmd.PersistentFlags(), &req.%s, %q, %q)", goPath, flagName, comment)
			}
		case protoreflect.StringKind:
			if fld.Desc.IsList() {
				flagLine = fmt.Sprintf("cmd.PersistentFlags().StringSliceVar(&req.%s, %q, nil, %q)", goPath, flagName, comment)
			} else if !fld.Desc.HasPresence() {
				flagLine = fmt.Sprintf("cmd.PersistentFlags().StringVar(&req.%s, %q, \"\", %q)", goPath, flagName, comment)
			} else {
				flagLine = fmt.Sprintf("flag.StringPointerVar(cmd.PersistentFlags(), &req.%s, %q, %q)", goPath, flagName, comment)
			}
		case protoreflect.BytesKind:
			if fld.Desc.IsList() {
				id := g.QualifiedGoIdent(flagPkg.Ident("BytesBase64SliceVar"))
				flagLine = fmt.Sprintf("%s(cmd.PersistentFlags(), &req.%s, %q, %q)", id, goPath, flagName, comment)
			} else {
				flagLine = fmt.Sprintf("cmd.PersistentFlags().BytesBase64Var(&req.%s, %q, nil, %q)", goPath, flagName, comment)
			}
		case protoreflect.EnumKind:
			e, ok := enums[fld.Enum.GoIdent.GoName]
			if !ok {
				e = &enum{Enum: fld.Enum}
				enums[fld.Enum.GoIdent.GoName] = e
			}
			if fld.Desc.IsList() {
				e.List = true
				flagLine = fmt.Sprintf("_%sSliceVar(cmd.PersistentFlags(), &req.%s, %q, %q)", fld.Enum.GoIdent.GoName, goPath, flagName, comment)
			} else if fld.Desc.HasPresence() {
				e.Pointer = true
				flagLine = fmt.Sprintf("_%sPointerVar(cmd.PersistentFlags(), &req.%s, %q, %q)", fld.Enum.GoIdent.GoName, goPath, flagName, comment)
			} else {
				e.Value = true
				flagLine = fmt.Sprintf("_%sVar(cmd.PersistentFlags(), &req.%s, %q, %q)", fld.Enum.GoIdent.GoName, goPath, flagName, comment)
			}
		case protoreflect.MessageKind, protoreflect.GroupKind:
			if fld.Desc.ContainingOneof() != nil {
				// oneof not supported
			} else if flagFuncs, ok := knownTypes[fld.Message.GoIdent]; ok {
				i := 0
				if fld.Desc.IsList() {
					i = 1
				}
				flagId := g.QualifiedGoIdent(flagFuncs[i])
				flagLine = fmt.Sprintf("%s(cmd.PersistentFlags(), &req.%s, %q, %q)", flagId, goPath, flagName, comment)
			} else if fld.Desc.IsList() {
				// message list not supported
			} else if fld.Desc.IsMap() {
				// TODO: expand map support
				if fld.Desc.MapKey().Kind() == protoreflect.StringKind {
					switch fld.Desc.MapValue().Kind() {
					case protoreflect.StringKind:
						flagLine = fmt.Sprintf("cmd.PersistentFlags().StringToStringVar(&req.%s, %q, nil, %q)", goPath, flagName, comment)
					case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
						flagLine = fmt.Sprintf("cmd.PersistentFlags().StringToInt64Var(&req.%s, %q, nil, %q)", goPath, flagName, comment)
					}
				}
			} else if visited[message.GoIdent] = true; visited[fld.Message.GoIdent] {
				// cycle detected
			} else {
				m := make(map[protogen.GoIdent]bool, len(visited))
				for k, v := range visited {
					m[k] = v
				}

				i, f := walkFields(g, fld.Message, path, enums, deprecated, m)
				if i != "" {
					initLines = append(initLines, fld.GoName+": "+i+",")
				}
				if f != "" {
					flagLines = append(flagLines, f)
				}
			}
		}

		if flagLine != "" {
			if deprecated {
				flagLine += fmt.Sprintf("; _ = cmd.PersistentFlags().MarkDeprecated(%q, \"deprecated\")", flagName)
			}
			flagLines = append(flagLines, flagLine)
		}
	}

	initCode := ""
	if len(initLines) > 0 {
		sort.Strings(initLines)
		initCode = fmt.Sprintf("\n%s\n", strings.Join(initLines, "\n"))
	}
	sort.Strings(flagLines)
	return fmt.Sprintf("&%s{%s}", g.QualifiedGoIdent(message.GoIdent), initCode), strings.Join(flagLines, "\n")
}

type enum struct {
	*protogen.Enum
	Value   bool
	Pointer bool
	List    bool
}

var (
	enumTemplateCode = `
{{if .Value}}
type _{{.GoIdent.GoName}}Value {{.GoIdent.GoName}}

func _{{.GoIdent.GoName}}Var(fs *pflag.FlagSet, p *{{.GoIdent.GoName}}, name, usage string) {
	fs.Var((*_{{.GoIdent.GoName}}Value)(p), name, usage)
}

func (v *_{{.GoIdent.GoName}}Value) Set(val string) error {
	if e, err := parse{{.GoIdent.GoName}}(val); err != nil {
		return err
	} else {
		*v = _{{.GoIdent.GoName}}Value(e)
		return nil
	}
}

func (v *_{{.GoIdent.GoName}}Value) Type() string { return "{{.GoIdent.GoName}}" }

func (v *_{{.GoIdent.GoName}}Value) String() string { return ({{.GoIdent.GoName}})(*v).String() }
{{end}}
{{if .Pointer }}
type _{{.GoIdent.GoName}}PointerValue struct {
	set func(*{{.GoIdent.GoName}})
}

func _{{.GoIdent.GoName}}PointerVar(fs *pflag.FlagSet, p **{{.GoIdent.GoName}}, name, usage string) *_{{.GoIdent.GoName}}PointerValue {
	return &_{{.GoIdent.GoName}}PointerValue{func(e *{{.GoIdent.GoName}}) { *p = e }}
}

func (v *_{{.GoIdent.GoName}}PointerValue) Set(val string) error {
	if e, err := parse{{.GoIdent.GoName}}(val); err != nil {
		return err
	} else {
		v.set(&e)
		return nil
	}
}

func (v *_{{.GoIdent.GoName}}PointerValue) Type() string { return "{{.GoIdent.GoName}}Pointer" }

func (v *_{{.GoIdent.GoName}}PointerValue) String() string { return "<nil>" }
{{end}}
{{if .List}}
type _{{.GoIdent.GoName}}SliceValue struct {
	value   *[]{{.GoIdent.GoName}}
	changed bool
}

func _{{.GoIdent.GoName}}SliceVar(fs *pflag.FlagSet, p *[]{{.GoIdent.GoName}}, name, usage string) {
	fs.Var(&_{{.GoIdent.GoName}}SliceValue{value: p}, name, usage)
}

func (s *_{{.GoIdent.GoName}}SliceValue) Set(val string) error {
	ss := strings.Split(val, ",")
	out := make([]{{.GoIdent.GoName}}, len(ss))
	for i, s := range ss {
		var err error
		if out[i], err = parse{{.GoIdent.GoName}}(s); err != nil {
			return err
		}
	}
	if !s.changed {
		*s.value = out
		s.changed = true
	} else {
		*s.value = append(*s.value, out...)
	}
	return nil
}

func (s *_{{.GoIdent.GoName}}SliceValue) Type() string { return "{{.GoIdent.GoName}}Slice" }

func (s *_{{.GoIdent.GoName}}SliceValue) String() string { return "[]" }
{{end}}
func parse{{.GoIdent.GoName}}(s string) ({{.GoIdent.GoName}}, error) {
	if i, ok := {{.GoIdent.GoName}}_value[s]; ok {
		return {{.GoIdent.GoName}}(i), nil
	} else if i, err := strconv.ParseInt(s, 0, 32); err == nil {
		return {{.GoIdent.GoName}}(i), nil
	} else {
		return 0, err
	}
}
`
	enumTemplate = template.Must(template.New("enum").Parse(enumTemplateCode))
	enumImports  = []protogen.GoImportPath{
		"strconv",
		"github.com/spf13/pflag",
	}
)

func genEnum(g *protogen.GeneratedFile, enum *enum) error {
	for _, imp := range enumImports {
		g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: imp})
	}
	if enum.List {
		g.QualifiedGoIdent(protogen.GoIdent{GoImportPath: "strings"})
	}
	return enumTemplate.Execute(g, enum)
}

func cleanComments(comments protogen.Comments) string {
	return strings.TrimSpace(string(comments))
}
